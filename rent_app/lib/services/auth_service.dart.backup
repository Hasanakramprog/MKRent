import 'dart:async';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/user.dart';
import '../services/notification_service.dart';

class AuthService {
  static final FirebaseAuth _auth = FirebaseAuth.instance;
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  static AppUser? _currentUser;

  static AppUser? get currentUser => _currentUser;
  static bool get isLoggedIn => _currentUser != null;
  static bool get isAdmin => _currentUser?.isAdmin ?? false;
  static bool get isCustomer => _currentUser?.isCustomer ?? false;
  static String? get userId => _currentUser?.id;

  // Initialize auth state
  static Future<void> initialize() async {
    try {
      print('Initializing AuthService...');
      final user = _auth.currentUser;
      if (user != null) {
        print('Found existing user: ${user.uid}');
        await _loadUserData(user.uid);
      } else {
        print('No existing user found');
      }
      print('AuthService initialization completed');
    } catch (e) {
      print('Error during AuthService initialization: $e');
      // Don't throw - let the app continue
    }
  }

  // Check if phone number is already registered
  static Future<bool> isPhoneRegistered(String phoneNumber) async {
    try {
      print('Checking if phone number is registered: $phoneNumber');
      
      // Query Firestore to check if a user with this phone number exists
      final query = await _firestore
          .collection('users')
          .where('phone', isEqualTo: phoneNumber)
          .limit(1)
          .get();
      
      final isRegistered = query.docs.isNotEmpty;
      print('Phone registration check result: $isRegistered');
      return isRegistered;
    } catch (e) {
      print('Error checking phone registration: $e');
      // If there's an error (like permission denied), treat as new user
      return false;
    }
  }

  // Send SMS verification code
  static Future<String?> sendSMSVerification(String phoneNumber) async {
    try {
      print('Starting SMS verification for: $phoneNumber');

      // Additional check to ensure Firebase is ready
      print('Checking Firebase app state...');
      print('Firebase app ID: ${_auth.app.name}');

      String? verificationId;
      final completer = Completer<String?>();
      bool isCompleted = false;

      print('Calling verifyPhoneNumber...');
      await _auth.verifyPhoneNumber(
        phoneNumber: phoneNumber,
        verificationCompleted: (PhoneAuthCredential credential) async {
          print('Auto verification completed');
          if (!isCompleted) {
            isCompleted = true;
            completer.complete('auto-verified');
          }
        },
        verificationFailed: (FirebaseAuthException e) {
          print('Verification failed: ${e.code} - ${e.message}');
          if (!isCompleted) {
            isCompleted = true;
            completer.completeError(
              FirebaseAuthException(
                code: e.code,
                message: e.message ?? 'SMS verification failed',
              ),
            );
          }
        },
        codeSent: (String verId, int? resendToken) {
          print('Code sent successfully. Verification ID: $verId');
          verificationId = verId;
          if (!isCompleted) {
            isCompleted = true;
            completer.complete(verId);
          }
        },
        codeAutoRetrievalTimeout: (String verId) {
          print('Auto retrieval timeout. Verification ID: $verId');
          if (!isCompleted) {
            verificationId = verId;
            isCompleted = true;
            completer.complete(verId);
          }
        },
        timeout: const Duration(seconds: 60),
      );

      // Wait for completion with timeout
      return await completer.future.timeout(
        const Duration(seconds: 70),
        onTimeout: () {
          print('Timeout reached, returning verification ID: $verificationId');
          return verificationId;
        },
      );
    } on FirebaseAuthException catch (e) {
      print('Firebase Auth Exception: ${e.code} - ${e.message}');
      throw FirebaseAuthException(
        code: e.code,
        message: _getFirebaseErrorMessage(e.code),
      );
    } catch (e) {
      print('General error in sendSMSVerification: $e');
      throw Exception('Failed to send SMS verification: ${e.toString()}');
    }
  }

  // Helper method to get user-friendly error messages
  static String _getFirebaseErrorMessage(String errorCode) {
    switch (errorCode) {
      case 'invalid-phone-number':
        return 'Please enter a valid phone number';
      case 'too-many-requests':
        return 'Too many attempts. Please try again later';
      case 'quota-exceeded':
        return 'SMS quota exceeded. Please try again later';
      case 'network-request-failed':
        return 'Network error. Please check your connection';
      case 'app-not-authorized':
        return 'App not authorized for SMS verification';
      default:
        return 'Verification failed. Please try again';
    }
  }

  // Verify SMS code and sign in existing user
  static Future<bool> signInWithPhone({
    required String verificationId,
    required String smsCode,
  }) async {
    try {
      print('Signing in existing user with verification ID: $verificationId');
      
      final PhoneAuthCredential credential = PhoneAuthProvider.credential(
        verificationId: verificationId,
        smsCode: smsCode,
      );

      final UserCredential userCredential = await _auth.signInWithCredential(
        credential,
      );

      if (userCredential.user != null) {
        print('User signed in successfully: ${userCredential.user!.uid}');
        await _loadUserData(userCredential.user!.uid);
        await _saveUserSession();
        return true;
      }
      return false;
    } catch (e) {
      print('Error signing in existing user: $e');
      rethrow;
    }
  }

  // Verify SMS code and create new user account
  static Future<bool> verifySMSAndSignIn({
    required String verificationId,
    required String smsCode,
    required String name,
    required UserRole role,
    String? email,
    String? storeId,
    String? storeName,
  }) async {
    try {
      print('Creating new user account with verification ID: $verificationId');
      
      final PhoneAuthCredential credential = PhoneAuthProvider.credential(
        verificationId: verificationId,
        smsCode: smsCode,
      );

      final UserCredential userCredential = await _auth.signInWithCredential(
        credential,
      );

      if (userCredential.user != null) {
        print('User authenticated successfully: ${userCredential.user!.uid}');
        
        // Check if user already exists in Firestore
        final userDoc = await _firestore
            .collection('users')
            .doc(userCredential.user!.uid)
            .get();

        if (!userDoc.exists) {
          print('Creating new user document in Firestore');
          // Create new user
          final newUser = AppUser(
            id: userCredential.user!.uid,
            name: name,
            phone: userCredential.user!.phoneNumber ?? '',
            role: role,
            email: email ?? '', // Handle nullable email
            storeId: storeId,
            storeName: storeName,
            createdAt: DateTime.now(),
          );

          await _firestore
              .collection('users')
              .doc(userCredential.user!.uid)
              .set(newUser.toMap());

          _currentUser = newUser;
          print('New user created successfully');
          
          // Handle FCM token for new user
          await _handleFCMTokenAfterLogin();
        } else {
          print('Loading existing user data');
          // Load existing user
          _currentUser = AppUser.fromMap(userDoc.data()!);
          
          // Handle FCM token for existing user
          await _handleFCMTokenAfterLogin();
        }

        await _saveUserSession();
        return true;
      }
      return false;
    } catch (e) {
      print('Error creating new user: $e');
      rethrow;
    }
  }

  // Load user data from Firestore
  static Future<void> _loadUserData(String uid) async {
    try {
      print('Loading user data for UID: $uid');
      final userDoc = await _firestore.collection('users').doc(uid).get();
      if (userDoc.exists) {
        _currentUser = AppUser.fromMap(userDoc.data()!);
        print('User data loaded successfully: ${_currentUser!.name}');
        
        // Handle FCM token after successful login
        await _handleFCMTokenAfterLogin();
      } else {
        print('No user document found for UID: $uid');
      }
    } catch (e) {
      print('Error loading user data: $e');
    }
  }

  // Handle FCM token after login
  static Future<void> _handleFCMTokenAfterLogin() async {
    try {
      await NotificationService.onUserLogin();
    } catch (e) {
      print('Error handling FCM token after login: $e');
    }
  }

  // Save user session locally
  static Future<void> _saveUserSession() async {
    if (_currentUser != null) {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('user_id', _currentUser!.id);
      await prefs.setString('user_name', _currentUser!.name);
      if (_currentUser!.phone != null) {
        await prefs.setString('user_phone', _currentUser!.phone!);
      }
      await prefs.setString('user_role', _currentUser!.role.toString());
      print('User session saved locally');
    }
  }

  // Load user session from local storage
  static Future<void> loadUserSession() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final userId = prefs.getString('user_id');

      if (userId != null && _auth.currentUser != null) {
        await _loadUserData(userId);
      }
    } catch (e) {
      print('Error loading user session: $e');
    }
  }

  // Update user profile
  static Future<bool> updateUserProfile({
    String? name,
    String? email,
    String? storeId,
    String? storeName,
  }) async {
    if (_currentUser == null) return false;

    try {
      final updatedUser = _currentUser!.copyWith(
        name: name,
        email: email,
        storeId: storeId,
        storeName: storeName,
        updatedAt: DateTime.now(),
      );

      await _firestore
          .collection('users')
          .doc(_currentUser!.id)
          .update(updatedUser.toMap());

      _currentUser = updatedUser;
      await _saveUserSession();
      return true;
    } catch (e) {
      print('Error updating profile: $e');
      return false;
    }
  }

  // Sign out
  static Future<void> signOut() async {
    try {
      // Handle FCM token before logout
      await NotificationService.onUserLogout();
      
      await _auth.signOut();
      _currentUser = null;

      final prefs = await SharedPreferences.getInstance();
      await prefs.clear();
      print('User signed out successfully');
    } catch (e) {
      print('Error signing out: $e');
    }
  }

  // Get user by phone number
  static Future<AppUser?> getUserByPhone(String phoneNumber) async {
    try {
      final query = await _firestore
          .collection('users')
          .where('phone', isEqualTo: phoneNumber)
          .get();

      if (query.docs.isNotEmpty) {
        return AppUser.fromMap(query.docs.first.data());
      }
      return null;
    } catch (e) {
      print('Error getting user by phone: $e');
      return null;
    }
  }
}
